phi = NULL,
type = 2)
aaa1 <- proc.time()
time_our <-aaa1 - aaa
index_use = c(1,2,3)
dd = rep(c(0:3), p_k_real * G)
result <- MAP_test(est_result = est_result, Type = c(1:6), dd = dd, nn = 300)
rm(list = ls())
library(Rmpi)
library(snow)
library(doSNOW)
library(foreach)
library(doRNG)
# library(DESeq)
library(DESeq2)
library(MASS)
library(mvtnorm)
library(randtoolbox)
library(stats)
library(mclust)
library(EQL)
library(matlib)
library(edgeR)
source("data_generation.R")
source("estimation_fun.R")
source("MAP_test.R")
source("Summary_MAP.R")
G = 1000
mu1_r = 4
p_k_real <- c(0.75, 0.15, 0.05, 0.05)
n_basis = 2
n_control = 6
n_treat   = 6
n_rep = 3
k_real = 4
tt_treat  = c(1:n_treat)/n_treat
nt = length(tt_treat)
ind_t = sort(sample(c(1:nt), n_control))
tt = tt_treat[ind_t]
tttt = c(rep(tt, n_rep), rep(tt_treat, n_rep))
z = x = matrix(0, length(tttt), n_basis)
z[,1] = 1.224745*tttt
z[,2] = -0.7905694 + 2.371708*tttt^2
x[,1] = z[,1] - Proj(z[,1], rep(1, length(tttt)))
x[,2] = z[,2] - Proj(z[,2], rep(1, length(tttt))) - Proj(z[,2], x[,1])
Y1 = data_generation(G = G,
n_control = n_control,
n_treat   = n_treat,
n_rep     = n_rep,
k_real = 4,
sigma2_r = rep(1, 1),
sigma1_2_r = 0.5,
sigma2_2_r = c(2,2),
mu1_r = mu1_r,
phi_g_r = rep(1, G),
p_k_real = p_k_real,
x = x)
aaa <- proc.time()
est_result <- estimation_fun(n_control = n_control,
n_treat = n_treat,
n_rep = n_rep,
x = x,
Y1 = Y1,
nn = 300,
k = 4,
phi = NULL,
type = 2)
aaa1 <- proc.time()
time_our <-aaa1 - aaa
index_use = c(1,2,3)
dd = rep(c(0:3), p_k_real * G)
result <- MAP_test(est_result = est_result, Type = c(1:6), dd = dd, nn = 300)
alpha = 0.05
ss1 <- Summary_MAP(result, alpha = alpha)
FDR1 <- sum(dd[ss1[[6]]$Reject_index] %in% c(index_use-1))/length(dd[ss1[[6]]$Reject_index])
Power1 <- sum(1 - dd[ss1[[6]]$Reject_index] %in% c(index_use-1)) / sum(1 - dd %in% c(index_use-1))
FDR1
Power1
rm(list = ls())
library(Rmpi)
library(snow)
library(doSNOW)
library(foreach)
library(doRNG)
# library(DESeq)
library(DESeq2)
library(MASS)
library(mvtnorm)
library(randtoolbox)
library(stats)
library(mclust)
library(EQL)
library(matlib)
library(edgeR)
source("data_generation.R")
source("estimation_fun.R")
source("MAP_test.R")
source("Summary_MAP.R")
G = 1000
mu1_r = 8
p_k_real <- c(0.75, 0.15, 0.05, 0.05)
n_basis = 2
n_control = 6
n_treat   = 6
n_rep = 3
k_real = 4
tt_treat  = c(1:n_treat)/n_treat
nt = length(tt_treat)
ind_t = sort(sample(c(1:nt), n_control))
tt = tt_treat[ind_t]
tttt = c(rep(tt, n_rep), rep(tt_treat, n_rep))
z = x = matrix(0, length(tttt), n_basis)
z[,1] = 1.224745*tttt
z[,2] = -0.7905694 + 2.371708*tttt^2
x[,1] = z[,1] - Proj(z[,1], rep(1, length(tttt)))
x[,2] = z[,2] - Proj(z[,2], rep(1, length(tttt))) - Proj(z[,2], x[,1])
Y1 = data_generation(G = G,
n_control = n_control,
n_treat   = n_treat,
n_rep     = n_rep,
k_real = 4,
sigma2_r = rep(1, 1),
sigma1_2_r = 0.5,
sigma2_2_r = c(4,4),
mu1_r = mu1_r,
phi_g_r = rep(1, G),
p_k_real = p_k_real,
x = x)
aaa <- proc.time()
est_result <- estimation_fun(n_control = n_control,
n_treat = n_treat,
n_rep = n_rep,
x = x,
Y1 = Y1,
nn = 300,
k = 4,
phi = NULL,
type = 2)
aaa1 <- proc.time()
time_our <-aaa1 - aaa
index_use = c(1,2,3)
dd = rep(c(0:3), p_k_real * G)
result <- MAP_test(est_result = est_result, Type = c(1:6), dd = dd, nn = 300)
alpha = 0.05
ss1 <- Summary_MAP(result, alpha = alpha)
FDR1 <- sum(dd[ss1[[6]]$Reject_index] %in% c(index_use-1))/length(dd[ss1[[6]]$Reject_index])
Power1 <- sum(1 - dd[ss1[[6]]$Reject_index] %in% c(index_use-1)) / sum(1 - dd %in% c(index_use-1))
FDR1
Power1
k <- 4
X1 <- c(rep(0, n_rep * n_control), rep(1, n_rep * n_treat))
tttt <- est_result$data_use$tttt
G <- dim(est_result$data_use$Y1)[1]
Y1 <- est_result$data_use$Y1
Time <- factor(tttt)
condition <- factor(X1)
dd = rep(c(0:3), p_k_real * G)
Y1_new <- Y1
sf <- rep(1, length(tttt))
ddsMat_interact_all <-
DESeqDataSetFromMatrix(countData = Y1_new,
DataFrame(condition, x),
design = ~ condition + V1 + V2 + condition : V1 + condition : V2)
sizeFactors(ddsMat_interact_all) <- sf
ddsTS2_interact_all <- DESeq(ddsMat_interact_all, test="LRT", reduced = ~ V1 + V2 + condition : V1 + condition : V2, betaPrior = F)
ress_interact <- results(ddsTS2_interact_all)
phi <- dispersions(ddsTS2_interact_all)
res1 <- which(ress_interact$padj <= 0.05)
# result1 <- MAP_test(est_result = est_result1, Type = c(1:6), dd = dd, nn = 3000)
# ss2 <- Summary_MAP(result1, alpha = alpha)
FDR2 <- sum(dd[ss2[[6]]$Reject_index] %in% c(index_use-1))/length(dd[ss2[[6]]$Reject_index])
Power2 <- sum(1 - dd[ss2[[6]]$Reject_index] %in% c(index_use-1)) / sum(1 - dd %in% c(index_use-1))
ddsTS2_interact_all2 <- DESeq(ddsMat_interact_all, test="LRT", reduced = ~ V1 + V2, betaPrior = F)
ress_interact2 <- results(ddsTS2_interact_all2)
res2 <- which(ress_interact2$padj <= 0.05)
ddsTS2_interact_all3 <- DESeq(ddsMat_interact_all, test="LRT", reduced = ~ condition + V1 + V2, betaPrior = F)
ress_interact3 <- results(ddsTS2_interact_all3)
res3 <- which(ress_interact3$padj <= 0.05)
rej_id_deseq2 <- intersect(res2, res3)
FDR_deseq <- sum(dd[rej_id_deseq2 ] %in% c(index_use-1))/length(dd[rej_id_deseq2 ])
Power_deseq <- sum(1 - dd[rej_id_deseq2 ] %in% c(index_use-1)) / sum(1 - dd %in% c(index_use-1))
FDR_deseq
Power_deseq
qq_n = 0.05
group <- factor(paste0(X1, ".", tttt))
d <- DGEList(Y1, group = group, lib.size = rep(1,ncol(Y1)),
norm.factors = rep(1,ncol(Y1)))
design_use <- as.data.frame(cbind(X1, x, X1*x))
names(design_use) = c(paste0(rep("X", n_basis + 1), c(1:(n_basis * 2 + 1))))
design = model.matrix(~ X1 + X2 + X3 + X4 + X5 , data = design_use)
# design = model.matrix(~group)
# d <- calcNormFactors(d)
d <- estimateDisp(d, design)
fit <- glmQLFit(d, design, robust=T)
res <- glmQLFTest(fit, coef = c(2))
is.de <- decideTestsDGE(res, p.value=qq_n)
rej <- which(is.de != 0)
res2 <- glmQLFTest(fit, coef = c(5,6))
is.de2 <- decideTestsDGE(res2, p.value=qq_n)
rej2 <- which(is.de2 != 0)
rej_id_edgeR <- intersect(rej, rej2)
FDR_edgeR <- sum(dd[rej_id_edgeR ] %in% c(index_use-1))/length(dd[rej_id_edgeR ])
Power_edgeR <- sum(1 - dd[rej_id_edgeR ] %in% c(index_use-1)) / sum(1 - dd %in% c(index_use-1))
c(FDR1,
Power1,
FDR_deseq,
Power_deseq,
FDR_edgeR,
Power_edgeR
)
FDR_edgeR
sum(dd[rej_id_edgeR ] %in% c(index_use-1))
length(dd[rej_id_edgeR ])
rm(list = ls())
library(Rmpi)
library(snow)
library(doSNOW)
library(foreach)
library(doRNG)
# library(DESeq)
library(DESeq2)
library(MASS)
library(mvtnorm)
library(randtoolbox)
library(stats)
library(mclust)
library(EQL)
library(matlib)
library(edgeR)
source("data_generation.R")
source("estimation_fun.R")
source("MAP_test.R")
source("Summary_MAP.R")
G = 1000
mu1_r = 8
p_k_real <- c(0.75, 0.15, 0.05, 0.05)
n_basis = 2
n_control = 6
n_treat   = 6
n_rep = 3
k_real = 4
tt_treat  = c(1:n_treat)/n_treat
nt = length(tt_treat)
ind_t = sort(sample(c(1:nt), n_control))
tt = tt_treat[ind_t]
tttt = c(rep(tt, n_rep), rep(tt_treat, n_rep))
z = x = matrix(0, length(tttt), n_basis)
z[,1] = 1.224745*tttt
z[,2] = -0.7905694 + 2.371708*tttt^2
x[,1] = z[,1] - Proj(z[,1], rep(1, length(tttt)))
x[,2] = z[,2] - Proj(z[,2], rep(1, length(tttt))) - Proj(z[,2], x[,1])
Y1 = data_generation(G = G,
n_control = n_control,
n_treat   = n_treat,
n_rep     = n_rep,
k_real = 4,
sigma2_r = rep(1, 1),
sigma1_2_r = 0.5,
sigma2_2_r = c(4,4),
mu1_r = mu1_r,
phi_g_r = rep(1, G),
p_k_real = p_k_real,
x = x)
aaa <- proc.time()
est_result <- estimation_fun(n_control = n_control,
n_treat = n_treat,
n_rep = n_rep,
x = x,
Y1 = Y1,
nn = 300,
k = 4,
phi = NULL,
type = 2)
aaa1 <- proc.time()
time_our <-aaa1 - aaa
index_use = c(1,2,3)
dd = rep(c(0:3), p_k_real * G)
result <- MAP_test(est_result = est_result, Type = c(1:6), dd = dd, nn = 300)
alpha = 0.05
ss1 <- Summary_MAP(result, alpha = alpha)
FDR1 <- sum(dd[ss1[[6]]$Reject_index] %in% c(index_use-1))/length(dd[ss1[[6]]$Reject_index])
Power1 <- sum(1 - dd[ss1[[6]]$Reject_index] %in% c(index_use-1)) / sum(1 - dd %in% c(index_use-1))
k <- 4
X1 <- c(rep(0, n_rep * n_control), rep(1, n_rep * n_treat))
tttt <- est_result$data_use$tttt
G <- dim(est_result$data_use$Y1)[1]
Y1 <- est_result$data_use$Y1
Time <- factor(tttt)
condition <- factor(X1)
dd = rep(c(0:3), p_k_real * G)
Y1_new <- Y1
sf <- rep(1, length(tttt))
ddsMat_interact_all <-
DESeqDataSetFromMatrix(countData = Y1_new,
DataFrame(condition, x),
design = ~ condition + V1 + V2 + condition : V1 + condition : V2)
sizeFactors(ddsMat_interact_all) <- sf
ddsTS2_interact_all <- DESeq(ddsMat_interact_all, test="LRT", reduced = ~ V1 + V2 + condition : V1 + condition : V2, betaPrior = F)
ress_interact <- results(ddsTS2_interact_all)
phi <- dispersions(ddsTS2_interact_all)
res1 <- which(ress_interact$padj <= 0.05)
# phi <- dispersions(ddsTS2_interact_all)
# # sum(dd[which(ress_interact$padj <= 0.05)]%in%c(1-1))/length(dd[which(ress_interact$padj <= 0.05)])
# # sum(1 - dd[which(ress_interact$padj <= 0.05)] %in%c(1-1))/sum(1 - dd %in% c(1-1))
# bbb1 = proc.time()
# bbb1 - bbb
# aaa <- proc.time()
# est_result1 <- estimation_fun(n_control = n_control,
#                               n_treat = n_treat,
#                               n_rep = n_rep,
#                               x = x,
#                               Y1 = Y1,
#                               nn = 300,
#                               k = 4,
#                               phi = phi)
# aaa1 <- proc.time()
# aaa1 - aaa
# result1 <- MAP_test(est_result = est_result1, Type = c(1:6), dd = dd, nn = 3000)
# ss2 <- Summary_MAP(result1, alpha = alpha)
# FDR2 <- sum(dd[ss2[[6]]$Reject_index] %in% c(index_use-1))/length(dd[ss2[[6]]$Reject_index])
# Power2 <- sum(1 - dd[ss2[[6]]$Reject_index] %in% c(index_use-1)) / sum(1 - dd %in% c(index_use-1))
ddsTS2_interact_all2 <- DESeq(ddsMat_interact_all, test="LRT", reduced = ~ V1 + V2, betaPrior = F)
ress_interact2 <- results(ddsTS2_interact_all2)
res2 <- which(ress_interact2$padj <= 0.05)
ddsTS2_interact_all3 <- DESeq(ddsMat_interact_all, test="LRT", reduced = ~ condition + V1 + V2, betaPrior = F)
ress_interact3 <- results(ddsTS2_interact_all3)
res3 <- which(ress_interact3$padj <= 0.05)
rej_id_deseq2 <- intersect(res2, res3)
FDR_deseq <- sum(dd[rej_id_deseq2 ] %in% c(index_use-1))/length(dd[rej_id_deseq2 ])
Power_deseq <- sum(1 - dd[rej_id_deseq2 ] %in% c(index_use-1)) / sum(1 - dd %in% c(index_use-1))
qq_n = 0.05
group <- factor(paste0(X1, ".", tttt))
d <- DGEList(Y1, group = group, lib.size = rep(1,ncol(Y1)),
norm.factors = rep(1,ncol(Y1)))
design_use <- as.data.frame(cbind(X1, x, X1*x))
names(design_use) = c(paste0(rep("X", n_basis + 1), c(1:(n_basis * 2 + 1))))
design = model.matrix(~ X1 + X2 + X3 + X4 + X5 , data = design_use)
# design = model.matrix(~group)
# d <- calcNormFactors(d)
d <- estimateDisp(d, design)
fit <- glmQLFit(d, design, robust=T)
res <- glmQLFTest(fit, coef = c(2))
is.de <- decideTestsDGE(res, p.value=qq_n)
rej <- which(is.de != 0)
res2 <- glmQLFTest(fit, coef = c(5,6))
is.de2 <- decideTestsDGE(res2, p.value=qq_n)
rej2 <- which(is.de2 != 0)
rej_id_edgeR <- intersect(rej, rej2)
FDR_edgeR <- sum(dd[rej_id_edgeR ] %in% c(index_use-1))/length(dd[rej_id_edgeR ])
Power_edgeR <- sum(1 - dd[rej_id_edgeR ] %in% c(index_use-1)) / sum(1 - dd %in% c(index_use-1))
c(FDR1,
Power1,
FDR_deseq,
Power_deseq,
FDR_edgeR,
Power_edgeR
)
rm(list = ls())
library(Rmpi)
library(snow)
library(doSNOW)
library(foreach)
library(doRNG)
# library(DESeq)
library(DESeq2)
library(MASS)
library(mvtnorm)
library(randtoolbox)
library(stats)
library(mclust)
library(EQL)
library(matlib)
library(edgeR)
source("data_generation.R")
source("estimation_fun.R")
source("MAP_test.R")
source("Summary_MAP.R")
G = 1000
mu1_r = 8
p_k_real <- c(0.75, 0.15, 0.05, 0.05)
n_basis = 2
n_control = 6
n_treat   = 6
n_rep = 3
k_real = 4
tt_treat  = c(1:n_treat)/n_treat
nt = length(tt_treat)
ind_t = sort(sample(c(1:nt), n_control))
tt = tt_treat[ind_t]
tttt = c(rep(tt, n_rep), rep(tt_treat, n_rep))
z = x = matrix(0, length(tttt), n_basis)
z[,1] = 1.224745*tttt
z[,2] = -0.7905694 + 2.371708*tttt^2
x[,1] = z[,1] - Proj(z[,1], rep(1, length(tttt)))
x[,2] = z[,2] - Proj(z[,2], rep(1, length(tttt))) - Proj(z[,2], x[,1])
Y1 = data_generation(G = G,
n_control = n_control,
n_treat   = n_treat,
n_rep     = n_rep,
k_real = 4,
sigma2_r = rep(1, 1),
sigma1_2_r = 0.5,
sigma2_2_r = c(4,4),
mu1_r = mu1_r,
phi_g_r = rep(1, G),
p_k_real = p_k_real,
x = x)
aaa <- proc.time()
est_result <- estimation_fun(n_control = n_control,
n_treat = n_treat,
n_rep = n_rep,
x = x,
Y1 = Y1,
nn = 300,
k = 4,
phi = NULL,
type = 2)
aaa1 <- proc.time()
time_our <-aaa1 - aaa
index_use = c(1,2,3)
dd = rep(c(0:3), p_k_real * G)
result <- MAP_test(est_result = est_result, Type = c(1:6), dd = dd, nn = 300)
alpha = 0.05
ss1 <- Summary_MAP(result, alpha = alpha)
FDR1 <- sum(dd[ss1[[6]]$Reject_index] %in% c(index_use-1))/length(dd[ss1[[6]]$Reject_index])
Power1 <- sum(1 - dd[ss1[[6]]$Reject_index] %in% c(index_use-1)) / sum(1 - dd %in% c(index_use-1))
k <- 4
X1 <- c(rep(0, n_rep * n_control), rep(1, n_rep * n_treat))
tttt <- est_result$data_use$tttt
G <- dim(est_result$data_use$Y1)[1]
Y1 <- est_result$data_use$Y1
Time <- factor(tttt)
condition <- factor(X1)
dd = rep(c(0:3), p_k_real * G)
Y1_new <- Y1
sf <- rep(1, length(tttt))
ddsMat_interact_all <-
DESeqDataSetFromMatrix(countData = Y1_new,
DataFrame(condition, x),
design = ~ condition + V1 + V2 + condition : V1 + condition : V2)
sizeFactors(ddsMat_interact_all) <- sf
ddsTS2_interact_all <- DESeq(ddsMat_interact_all, test="LRT", reduced = ~ V1 + V2 + condition : V1 + condition : V2, betaPrior = F)
ress_interact <- results(ddsTS2_interact_all)
phi <- dispersions(ddsTS2_interact_all)
res1 <- which(ress_interact$padj <= 0.05)
# phi <- dispersions(ddsTS2_interact_all)
# # sum(dd[which(ress_interact$padj <= 0.05)]%in%c(1-1))/length(dd[which(ress_interact$padj <= 0.05)])
# # sum(1 - dd[which(ress_interact$padj <= 0.05)] %in%c(1-1))/sum(1 - dd %in% c(1-1))
# bbb1 = proc.time()
# bbb1 - bbb
# aaa <- proc.time()
# est_result1 <- estimation_fun(n_control = n_control,
#                               n_treat = n_treat,
#                               n_rep = n_rep,
#                               x = x,
#                               Y1 = Y1,
#                               nn = 300,
#                               k = 4,
#                               phi = phi)
# aaa1 <- proc.time()
# aaa1 - aaa
# result1 <- MAP_test(est_result = est_result1, Type = c(1:6), dd = dd, nn = 3000)
# ss2 <- Summary_MAP(result1, alpha = alpha)
# FDR2 <- sum(dd[ss2[[6]]$Reject_index] %in% c(index_use-1))/length(dd[ss2[[6]]$Reject_index])
# Power2 <- sum(1 - dd[ss2[[6]]$Reject_index] %in% c(index_use-1)) / sum(1 - dd %in% c(index_use-1))
ddsTS2_interact_all2 <- DESeq(ddsMat_interact_all, test="LRT", reduced = ~ V1 + V2, betaPrior = F)
ress_interact2 <- results(ddsTS2_interact_all2)
res2 <- which(ress_interact2$padj <= 0.05)
ddsTS2_interact_all3 <- DESeq(ddsMat_interact_all, test="LRT", reduced = ~ condition + V1 + V2, betaPrior = F)
ress_interact3 <- results(ddsTS2_interact_all3)
res3 <- which(ress_interact3$padj <= 0.05)
rej_id_deseq2 <- intersect(res2, res3)
FDR_deseq <- sum(dd[rej_id_deseq2 ] %in% c(index_use-1))/length(dd[rej_id_deseq2 ])
Power_deseq <- sum(1 - dd[rej_id_deseq2 ] %in% c(index_use-1)) / sum(1 - dd %in% c(index_use-1))
qq_n = 0.05
group <- factor(paste0(X1, ".", tttt))
d <- DGEList(Y1, group = group, lib.size = rep(1,ncol(Y1)),
norm.factors = rep(1,ncol(Y1)))
design_use <- as.data.frame(cbind(X1, x, X1*x))
names(design_use) = c(paste0(rep("X", n_basis + 1), c(1:(n_basis * 2 + 1))))
design = model.matrix(~ X1 + X2 + X3 + X4 + X5 , data = design_use)
# design = model.matrix(~group)
# d <- calcNormFactors(d)
d <- estimateDisp(d, design)
fit <- glmQLFit(d, design, robust=T)
res <- glmQLFTest(fit, coef = c(2))
is.de <- decideTestsDGE(res, p.value=qq_n)
rej <- which(is.de != 0)
res2 <- glmQLFTest(fit, coef = c(5,6))
is.de2 <- decideTestsDGE(res2, p.value=qq_n)
rej2 <- which(is.de2 != 0)
rej_id_edgeR <- intersect(rej, rej2)
FDR_edgeR <- sum(dd[rej_id_edgeR ] %in% c(index_use-1))/length(dd[rej_id_edgeR ])
Power_edgeR <- sum(1 - dd[rej_id_edgeR ] %in% c(index_use-1)) / sum(1 - dd %in% c(index_use-1))
c(FDR1,
Power1,
FDR_deseq,
Power_deseq,
FDR_edgeR,
Power_edgeR
)
intersect(res2, res3)
ress_interact3 <- results(ddsTS2_interact_all3)
res3 <- which(ress_interact3$padj <= 0.05)
rej_id_deseq2 <- intersect(res2, res3)
intersect(res2, res3)
res2 <- which(ress_interact2$padj <= 0.05)
res3 <- which(ress_interact3$padj <= 0.05)
rej_id_deseq2 <- intersect(res2, res3)
rej_id_deseq2
dd[rej_id_deseq2 ]
rej_id_edgeR
